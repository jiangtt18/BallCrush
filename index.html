<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>bubbleCrush</title>
    <style>
    #canvas {
      margin:30px;
      border: 1px solid black;
    }

    #startBtn {
      position: absolute;
      top:400px;
      left:250px;
      height:50px;
      font-size: 20px;
    }
    </style>
  </head>
  <body >
    <h1>Here we are!</h1>
    <canvas id='canvas' width='600' height='700'></canvas>
    <img id='rose' src="lib/images/rose.png" style='display:none;'>
    <img id='orange' src="lib/images/orange.png" style='display:none;'>
    <img id='lemon' src="lib/images/lemon.png" style='display:none;'>
    <img id='grey' src="lib/images/grey.png" style='display:none;'>
    <img id='lime' src="lib/images/lime.png" style='display:none;'>
    <img id='grapefruit' src="lib/images/grapefruit.png" style='display:none;'>
    <img id='blue' src="lib/images/blue.png" style='display:none;'>
    <audio src='lib/sound/sound.wav' id='sound'></audio>
    <!-- <audio src='lib/sound/BitQuest.wav' id='bgm'></audio> -->

    <button type='button' id= 'startBtn' onclick='initialize()'> START</button>

    <script>
      var ctx;
      const bubbles = [];
      var moves = [];
      var moveCount = 0;
      var score;
      var animationMoveTime;
      const images = [rose, orange, lemon, grey, lime, grapefruit, blue];
      var startBtn = document.getElementById('startBtn');
      var startPosX = null;
      var startPosY = null;
      var sound = document.getElementById('sound');
      function Bubble(x, y) {
        // assign bubble
        this.x1 = x;
        this.y1 = y;
        this.animationInterval = 0;

        this.x2 = x;
        this.y2 = y;

        this.getY = function(){

          return (this.y1 + (this.y2-this.y1) * (this.animationInterval)/25) * 60 + 100;
        }

        this.setBubbleProp = function (x2, y2, colorIdx){
          this.x2 = x2;
          this.y2 = y2;
          this.colorIdx = colorIdx;
          this.moving = true;
          this.animationInterval = 25;// cnotrol the time between drop and swap
          moves.push(this);
        }

        this.update = function(){
          this.animationInterval--;

          console.log(this.animationInterval);

          if(this.animationInterval <= 0) {
            this.moving = false;
          }
        }
      }

      function initialize(){
        startBtn.style.display = 'none';
        moveCount = 3;
        score = 0;
        initBubbleBoard();
        initBubbleColor();
        initCanvas();
        // debugger;
        animationMoveTime = setInterval(checkBubbleStatus, 25);//swapping motion time
        // call continuesly . will always run down from 25 animationInteval. but will control the run down speed
        console.log(animationMoveTime)

      }

      function initBubbleBoard(){
        for(let x = 0; x < 10; x++) {
          bubbles[x] = [];
          for(let y = 0; y < 10; y++) {
            bubbles[x][y] = new Bubble(x, y);
          }
        }
      }

      function initBubbleColor(){
        for(let x = 0; x < 10; x ++){
          for(let y = 0; y < 10; y ++){
            let foundcolor = false;
            while(!foundcolor){
              foundcolor = false;
              let randomIndex = getRandomNum(6);
              if(!hasStraight3colors(x, y, randomIndex)){
                bubbles[x][y].colorIdx = randomIndex;
                foundcolor = true;
              }
            }
          }
        }
      }

      function initCanvas(){
        let canvas = document.getElementById('canvas');
        ctx = canvas.getContext('2d');
        canvas.onmousedown = pressMouse;
        canvas.onmouseup = releaseMouse;
      }


      function checkBubbleStatus(){
          if(moves.length > 0){
             console.log(moves);
            for(let i = 0; i < moves.length; i++){
              // debugger;
              moves[i].update()
            }

            moves = moves.filter(
              function(bubble) {
                return bubble.animationInterval != 0;
              }
            );

            if(moves.length == 0) {
              setRemoveMark();
              fall();
            }
          }
            draw();

            if(moves.length == 0 && moveCount == 0) {
              clearInterval(animationMoveTime);
              animationMoveTime = null;
              setTimeout('gameOver()', 500)
            }
      }

      function gameOver(){
        ctx.clearRect(0,0,600,700);
        startBtn.style.display = 'inline';
        ctx.font = 'bold 30px Open Sans';
        ctx.fillText('Score: ' + score, 300,250);
      }


      function setRemoveMark(){
        setHorizontalRemoveMark();
        setVerticalRemoveMark();

      }

      function setHorizontalRemoveMark(){
        for(let x = 0; x < 10; x++){
          let currentColorIdx = bubbles[x][0].colorIdx;
          let numSameColor = 1;
          for(let y = 1; y < 10; y ++){
            let nextColorIdx = bubbles[x][y].colorIdx;
            if(currentColorIdx == nextColorIdx) {
              numSameColor ++;
              if ( numSameColor >= 3){
                bubbles[x][y-2].remove = true
                bubbles[x][y-1].remove = true
                bubbles[x][y].remove = true
              }
            } else {
              currentColorIdx = nextColorIdx;
              numSameColor = 1;
            }
          }
        }
      }

      function setVerticalRemoveMark(){
        for(let y = 0; y < 10; y++){
          let currentColorIdx = bubbles[0][y].colorIdx;
          var numSameColor = 1;
          for(let x = 1; x < 10; x++){
            let nextColorIdx = bubbles[x][y].colorIdx;
            if(currentColorIdx == nextColorIdx) {
              numSameColor++;
              if(numSameColor >= 3){
                bubbles[x-2][y].remove = true;
                bubbles[x-1][y].remove = true;
                bubbles[x][y].remove = true;
              }
            } else {
              currentColorIdx = nextColorIdx;
              numSameColor = 1;
            }
          }
        }
      }




      function fall(){
        for(let x = 0; x < 10; x++){
          for(let y = 9, newIdx = 9; y >= 0; y--, newIdx--){
            while (newIdx >= 0){
              if (bubbles[x][newIdx].remove){
                newIdx--;
              } else {
                break;
              }
            }

            if(y != newIdx) {
              var colorIdx = (newIdx >= 0) ? bubbles[x][newIdx].colorIdx : getRandomNum(6);
              bubbles[x][y].setBubbleProp(x,newIdx,colorIdx);
            }
          }
        }

        resetMark();
      }

      let playSound = true;
      function resetMark(){
        for(let x = 0; x < 10; x++){
          for(let y = 0; y < 10; y++) {
            if(bubbles[x][y].remove){
              bubbles[x][y].remove = false;
              score += 100;
              if(playSound){
                sound.pause();
                sound.currentTime = 0;
                sound.play();
                playSound = false;
              }
            }
          }
        }
      }

      function getRandomNum(n){
        return  Math.floor(Math.random() * n);
      }

      function hasStraight3colors(x,y,curBubble){
        let hasStraight3colors = false;
        if(y > 1) {
          let bottomBubble = bubbles[x][y-2].colorIdx;
          let middleBubble = bubbles[x][y-1].colorIdx;
          if(bottomBubble == middleBubble && middleBubble == curBubble){
            hasStraight3colors = true;
          }
        }

        if(x > 1) {
          let leftBubble = bubbles[x-2][y].colorIdx;
          let middleBubble = bubbles[x-1][y].colorIdx;
          if (leftBubble == middleBubble && middleBubble == curBubble){
            hasStraight3colors = true;
          }
        }

        return hasStraight3colors;
      }



      function draw() {
        ctx.clearRect(0,0,600,700);
        for(let x = 0; x < 10; x ++) {
          for(let y = 0; y < 10; y ++) {
            let idx = bubbles[x][y].colorIdx
            ctx.drawImage(images[idx],
            x * 60, bubbles[x][y].getY(), 60, 60)
          }
        }

        ctx.font = 'bold 20px Open Sans';
        ctx.textAlign = 'center';
        ctx.fillText('Moves Left:'+ moveCount, 150, 50);
        ctx.fillText('Score :' + score, 450, 50);
      }

      function pressMouse(e) {
        startPosX = e.offsetX;
        startPosY = e.offsetY;
        // console.log('dX:' + startPosX);
        // console.log('dY:' + startPosY);
      }

      function releaseMouse(e){
        let oldX = Math.floor(startPosX / 60);
        let oldY = Math.floor((startPosY - 100) / 60);
        // console.log('bubbleX:' + oldX);
        // console.log('bubbleY:' + oldY);
        let endPosX = e.offsetX;
        let endPosY = e.offsetY;
        let newPos = calcNewPos(startPosX, endPosX, startPosY, endPosY, oldX, oldY);
        let newX = newPos[0];
        let newY = newPos[1];
        //
        // console.log('bubbleX:' + newX);
        // console.log('bubbleY:' + newY);
        // debugger;
        if(bubbles[oldX][oldY].moving || bubbles[newX][newY].moving || animationMoveTime == null) {
          // let it drops
          return
        }
        swapColorsAndPos(oldX, oldY, newX, newY); // drop to the ideal position. stops.
        moveCount--;
        draw();
      }

      function swapColorsAndPos(oldX, oldY, newX, newY){
        let oldBubble = bubbles[oldX][oldY];
        let newBubble = bubbles[newX][newY];
        let oldColorIdx = oldBubble.colorIdx;
        oldBubble.setBubbleProp(newX, newY, newBubble.colorIdx);
        newBubble.setBubbleProp(oldX, oldY, oldColorIdx);

      }

      function calcNewPos (startPosX, endPosX, startPosY, endPosY, oldX, oldY) {
        let xDistance = endPosX - startPosX;
        let yDistance = endPosY - startPosY;
        let x = oldX;
        let y = oldY;
        if(Math.abs(xDistance) == 0 && Math.abs(yDistance) == 0){
          return;
        } else if (Math.abs(endPosX - startPosX) > Math.abs(yDistance)) {
          x += (xDistance > 0) ? 1 : -1;
        } else {
          y += (yDistance > 0) ? 1 : -1;
        }
        return [x,y];
      }

    </script>





  </body>



</html>
